from textual.app import ComposeResult
from textual.widgets import Input
from textual.containers import VerticalGroup
from typing import Optional, Tuple, Any, cast
from .config_field import ConfigField
from ..utils.logging import get_logger

logger = get_logger('text_field')

class TextField(ConfigField):
    """Champ texte avec m√©canisme de mise √† jour contr√¥l√©"""
    
    def __init__(self, source_id: str, field_id: str, field_config: dict, fields_by_id: dict = None, is_global: bool = False):
        """Initialisation du champ texte"""
        # Initialiser les propri√©t√©s pour le contr√¥le des mises √† jour AVANT d'appeler super().__init__
        # car ConfigField va acc√©der √† self.value qui d√©pend de ces propri√©t√©s
        self._internal_value: str = ""            # Valeur interne, toujours disponible
        self._updating_internally: bool = False   # Flag pour bloquer les mises √† jour cycliques
        self._pending_value: Optional[str] = None # Valeur en attente (widget pas encore mont√©)
        self._update_counter: int = 0            # Compteur pour d√©tecter les cascades
        
        # Maintenant appeler l'initialisation du parent
        super().__init__(source_id, field_id, field_config, fields_by_id, is_global)
        
        # Si la valeur a √©t√© modifi√©e par ConfigField via self.value, elle sera d√©j√† dans self._internal_value
        # Sinon, initialiser avec la valeur par d√©faut
        if not self._internal_value and 'default' in self.field_config:
            initial_value = self.field_config.get('default', '')
            if initial_value is not None:
                self._internal_value = str(initial_value)
                logger.debug(f"Valeur initiale pour {self.field_id}: '{self._internal_value}'")
    
    def compose(self) -> ComposeResult:
        """Cr√©ation des √©l√©ments visuels du champ"""
        # Composer les √©l√©ments de base (label, etc.)
        yield from super().compose()
        
        # Essayer de r√©cup√©rer la valeur de la s√©quence avant de cr√©er le widget
        self._try_load_sequence_value()
        
        # Conteneur pour l'input
        with VerticalGroup(classes="input-container", id=f"container_{self.field_id}"):
            # Cr√©er le widget Input avec la valeur interne actuelle
            input_value = self._internal_value
            logger.debug(f"üíª Cr√©ation du widget input pour {self.field_id} avec valeur: '{input_value}'")
            
            self.input = Input(
                placeholder=self.field_config.get('placeholder', ''),
                value=input_value,
                id=f"input_{self.field_id}"
            )
            # √âtat initial: activ√©
            self.input.disabled = False
            self.input.remove_class('disabled')

            # Si le champ est d√©sactiv√© via enabled_if
            if self.disabled:
                logger.debug(f"Champ {self.field_id} d√©sactiv√© initialement")
                self.input.disabled = True
                self.input.add_class('disabled')
            yield self.input
            
    def _try_load_sequence_value(self):
        """Essaie de charger la valeur depuis la configuration pr√©d√©finie (s√©quence)"""
        try:
            # Trouver l'√©cran de configuration
            from .config_screen import PluginConfig
            config_screen = None
            
            # Rechercher l'√©cran de configuration dans la hi√©rarchie des anc√™tres
            app = self.app if hasattr(self, 'app') and self.app else None
            if app and hasattr(app, 'screen') and isinstance(app.screen, PluginConfig):
                config_screen = app.screen
            
            if not config_screen or not hasattr(config_screen, 'current_config'):
                return
            
            # R√©cup√©rer le conteneur parent
            from .plugin_config_container import PluginConfigContainer
            parent = next((a for a in self.ancestors_with_self if isinstance(a, PluginConfigContainer)), None)
            if not parent or not hasattr(parent, 'id'):
                return
            
            # R√©cup√©rer l'ID de l'instance du plugin
            plugin_instance_id = parent.id.replace('plugin_', '')
            if plugin_instance_id not in config_screen.current_config:
                return
                
            # R√©cup√©rer la configuration pr√©d√©finie
            predefined_config = config_screen.current_config[plugin_instance_id]
            
            # Obtenir la variable ou config, selon le format
            variable_name = self.field_config.get('variable', self.field_id)
            
            # Chercher dans 'config' (nouveau format)
            if 'config' in predefined_config and variable_name in predefined_config['config']:
                value = predefined_config['config'][variable_name]
                if value is not None:
                    logger.debug(f"üíæ Valeur trouv√©e dans s√©quence pour {self.field_id}: '{value}'")
                    self._internal_value = str(value) if value is not None else ""
                    return
                    
            # Format 2: Chercher directement (ancien format)
            elif variable_name in predefined_config:
                value = predefined_config[variable_name]
                if value is not None:
                    logger.debug(f"üíæ Valeur trouv√©e dans s√©quence (ancien format) pour {self.field_id}: '{value}'")
                    self._internal_value = str(value) if value is not None else ""
                    return
                    
        except Exception as e:
            logger.error(f"Erreur lors de la r√©cup√©ration de la valeur de s√©quence pour {self.field_id}: {e}")
            import traceback
            logger.error(traceback.format_exc())
    
    def on_mount(self) -> None:
        """Ex√©cut√© apr√®s cr√©ation des widgets"""
        logger.debug(f"üö® MONTAGE du champ {self.field_id}")
        
        # Appliquer une valeur en attente si elle existe
        if self._pending_value is not None:
            logger.debug(f"Application de la valeur en attente '{self._pending_value}' pour {self.field_id}")
            self._set_widget_value(self._pending_value)
            self._pending_value = None  # R√©initialiser apr√®s usage
        else:
            logger.debug(f"Pas de valeur en attente pour {self.field_id}, valeur actuelle: '{self._internal_value}'")
        
        # V√©rifier la validation au montage
        self._validate_and_update_ui(self._internal_value)
    
    def validate_input(self, value: str) -> Tuple[bool, str]:
        """Validation selon les r√®gles configur√©es"""
        # Si le champ est d√©sactiv√©, pas de validation n√©cessaire
        if self.disabled:
            return True, ""

        # Champ obligatoire
        if self.field_config.get('not_empty', False) and not value:
            return False, "Ce champ ne peut pas √™tre vide"

        # Longueur minimale
        min_length = self.field_config.get('min_length')
        if min_length and len(value) < min_length:
            return False, f"La longueur minimale est de {min_length} caract√®res"

        # Longueur maximale
        max_length = self.field_config.get('max_length')
        if max_length and len(value) > max_length:
            return False, f"La longueur maximale est de {max_length} caract√®res"

        # Espaces interdits
        if self.field_config.get('validate') == 'no_spaces' and ' ' in value:
            return False, "Les espaces ne sont pas autoris√©s"

        # Valide par d√©faut
        return True, ""
    
    def _validate_and_update_ui(self, value: str) -> bool:
        """Valide la valeur et met √† jour l'interface utilisateur en cons√©quence"""
        # Seulement si le widget existe
        if not hasattr(self, 'input'):
            return True
            
        # Valider
        is_valid, error_msg = self.validate_input(value)
        
        # Mettre √† jour l'interface selon la validation
        if is_valid:
            self.input.remove_class('error')
            self.input.tooltip = None
        else:
            self.input.add_class('error')
            self.input.tooltip = error_msg
            logger.debug(f"Validation √©chou√©e pour {self.field_id}: {error_msg}")
            
        return is_valid
    
    def _set_widget_value(self, value: str) -> None:
        """Met √† jour le widget avec la valeur donn√©e, sans d√©clencher d'√©v√©nements"""
        if not hasattr(self, 'input'):
            logger.debug(f"Widget input non cr√©√© pour {self.field_id}, stockage de '{value}' en attente")
            self._pending_value = value
            return
            
        # V√©rifier si la valeur actuelle est diff√©rente
        current_widget_value = self.input.value
        if current_widget_value == value:
            logger.debug(f"Widget d√©j√† √† la valeur '{value}' pour {self.field_id}, rien √† faire")
            return
            
        logger.debug(f"Mise √† jour du widget pour {self.field_id}: '{current_widget_value}' ‚Üí '{value}'")
        self.input.value = value
        
        # Valider et mettre √† jour l'UI
        self._validate_and_update_ui(value)
    
    def set_value(self, value: str, update_input: bool = True, update_dependencies: bool = True) -> bool:
        """D√©finit la valeur du champ avec m√©canisme anti-cycles complet"""
        # Conversion √† la cha√Æne pour uniformit√©
        value_str = str(value) if value is not None else ""
        
        # ===== PHASE 1: V√©rifications pr√©liminaires =====
        self._update_counter += 1
        logger.debug(f"üîî [{self._update_counter}] set_value({value_str}) pour {self.field_id}, update_input={update_input}")
        
        # V√©rification 1: Pr√©venir les mises √† jour r√©cursives
        if self._updating_internally:
            logger.debug(f"‚ö†Ô∏è D√©j√† en cours de mise √† jour pour {self.field_id}, √©vitement cycle")
            return True
            
        # V√©rification 2: Valeur identique √† la valeur interne actuelle
        if self._internal_value == value_str:
            logger.debug(f"‚úì Valeur interne d√©j√† √† '{value_str}' pour {self.field_id}")
            return True
        
        # Marquer le d√©but de la mise √† jour
        self._updating_internally = True
        
        try:
            # ===== PHASE 2: Mise √† jour de la valeur interne =====
            old_value = self._internal_value
            self._internal_value = value_str
            logger.debug(f"üíæ Valeur interne mise √† jour pour {self.field_id}: '{old_value}' ‚Üí '{value_str}'")
            
            # ===== PHASE 3: Mise √† jour du widget si demand√© =====
            if update_input:
                self._set_widget_value(value_str)
                
            # ===== PHASE 4: Mise √† jour des d√©pendances si demand√© =====
            if update_dependencies:
                from .config_container import ConfigContainer
                parent = next((a for a in self.ancestors_with_self if isinstance(a, ConfigContainer)), None)
                if parent:
                    logger.debug(f"üîó Notification des d√©pendances pour {self.field_id}")
                    parent.update_dependent_fields(self)
                       
            logger.debug(f"‚úÖ set_value r√©ussi pour {self.field_id}")
            return True
            
        except Exception as e:
            # Capturer les exceptions pour √©viter de bloquer l'interface
            logger.error(f"‚ùå Erreur dans set_value pour {self.field_id}: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return False
            
        finally:
            # CRUCIAL: Toujours r√©initialiser le flag pour permettre des mises √† jour futures
            self._updating_internally = False
    
    def on_input_changed(self, event: Input.Changed) -> None:
        """Gestionnaire d'√©v√©nement quand l'utilisateur modifie l'input"""
        # V√©rifier que c'est bien notre input qui a chang√©
        if event.input.id != f"input_{self.field_id}":
            return
            
        # Si nous sommes en train de mettre √† jour l'input programmatiquement, ignorer
        if self._updating_internally:
            logger.debug(f"‚ö†Ô∏è Ignorer on_input_changed pendant mise √† jour pour {self.field_id}")
            return
            
        # Valeur diff√©rente de la valeur interne?
        value = str(event.value) if event.value is not None else ""
        if self._internal_value == value:
            logger.debug(f"‚úì on_input_changed: valeur d√©j√† √† jour pour {self.field_id}: '{value}'")
            return
            
        logger.debug(f"üëÅÔ∏è on_input_changed pour {self.field_id}: '{self._internal_value}' ‚Üí '{value}'")
        # Appeler set_value sans mettre √† jour l'input (d√©j√† fait par l'utilisateur)
        self.set_value(value, update_input=False)
    
    # Interface de propri√©t√© pour acc√®s simplifi√©
    @property
    def value(self) -> str:
        """Acc√®s √† la valeur interne"""
        return self._internal_value
        
    @value.setter
    def value(self, new_value: Any) -> None:
        """Modification de la valeur via l'accesseur"""
        # D√©l√©guer √† set_value, sans notification pour √©viter les cycles
        if self._updating_internally:
            self._internal_value = str(new_value) if new_value is not None else ""
        else:
            self.set_value(new_value, update_dependencies=False)
    
    def get_value(self) -> str:
        """R√©cup√©ration de la valeur pour l'export"""
        return self._internal_value