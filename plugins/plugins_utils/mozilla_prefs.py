#!/usr/bin/env python3
"""
Module utilitaire pour lire et écrire les fichiers de préférences Mozilla (Firefox, Thunderbird).
Gère les fichiers comme prefs.js, user.js, et les fichiers .cfg de politiques d'entreprise.
"""

from plugins_utils.config_files import ConfigFileCommands
from pathlib import Path
import os
import re
import json
import tempfile
import shutil
from typing import Union, Optional, List, Dict, Any, Tuple

class MozillaPrefsCommands(ConfigFileCommands):
    """
    Classe pour manipuler les fichiers de préférences Mozilla (Firefox, Thunderbird).
    Hérite de ConfigFileCommands pour réutiliser ses fonctionnalités de base.
    """

    def __init__(self, logger=None, target_ip=None):
        """Initialise le gestionnaire de fichiers de préférences Mozilla."""
        super().__init__(logger, target_ip)

    def _parse_prefs_js(self, content: str) -> Dict[str, Any]:
        """
        Parse un fichier prefs.js ou user.js de Mozilla.

        Args:
            content: Contenu du fichier à parser

        Returns:
            Dict[str, Any]: Dictionnaire des préférences {nom: valeur}
        """
        self.log_debug("Parsing d'un fichier de préférences Mozilla")

        # Regex pour extraire les préférences user_pref("nom", valeur);
        pref_pattern = r'user_pref\("([^"]+)",\s*([^)]+)\);'
        matches = re.findall(pref_pattern, content)

        prefs = {}

        for name, value_str in matches:
            # Convertir la valeur en type Python approprié
            try:
                # Essayer de parser en JSON pour obtenir le type correct
                # Remplacer les valeurs true/false JavaScript par les équivalents JSON
                value_str = value_str.replace('true', 'true').replace('false', 'false')
                value = json.loads(value_str)
            except json.JSONDecodeError:
                # Si échec, conserver comme chaîne
                value = value_str.strip('"\'')

            prefs[name] = value

        return prefs

    def _format_prefs_js(self, prefs: Dict[str, Any]) -> str:
        """
        Formate un dictionnaire de préférences en contenu de fichier prefs.js.

        Args:
            prefs: Dictionnaire des préférences {nom: valeur}

        Returns:
            str: Contenu formaté pour un fichier prefs.js
        """
        lines = [
            '// Mozilla User Preferences',
            '',
            '// DO NOT EDIT THIS FILE.',
            '//',
            '// If you make changes to this file while the application is running,',
            '// the changes will be overwritten when the application exits.',
            '//',
            '// To make a manual change to preferences, you can visit the URL about:config',
            '// or edit user.js in your profile directory.',
            ''
        ]

        # Trier les préférences pour une sortie prévisible
        sorted_prefs = sorted(prefs.items())

        for name, value in sorted_prefs:
            # Formater la valeur en fonction de son type
            if isinstance(value, str):
                # Les chaînes doivent être entre guillemets doubles
                value_str = f'"{value}"'
            elif isinstance(value, bool):
                # Convertir les booléens Python en booléens JavaScript
                value_str = 'true' if value else 'false'
            else:
                # Nombres et autres valeurs
                value_str = str(value)

            lines.append(f'user_pref("{name}", {value_str});')

        return '\n'.join(lines) + '\n'

    def read_prefs_file(self, path: Union[str, Path]) -> Optional[Dict[str, Any]]:
        """
        Lit un fichier de préférences Mozilla (prefs.js ou user.js).

        Args:
            path: Chemin du fichier de préférences

        Returns:
            Optional[Dict[str, Any]]: Dictionnaire des préférences {nom: valeur} ou None en cas d'erreur
        """
        file_path = Path(path)
        self.log_debug(f"Lecture du fichier de préférences Mozilla: {file_path}")

        # Lire le contenu du fichier
        content = self._read_file_content(file_path)
        if content is None:
            return None

        try:
            # Parser le contenu
            prefs = self._parse_prefs_js(content)
            self.log_debug(f"Fichier de préférences lu avec succès: {len(prefs)} préférences trouvées")
            return prefs
        except Exception as e:
            self.log_error(f"Erreur lors du parsing du fichier de préférences {file_path}: {e}", exc_info=True)
            return None

    def write_prefs_file(self, path: Union[str, Path], prefs: Dict[str, Any], backup: bool = True) -> bool:
        """
        Écrit un dictionnaire de préférences dans un fichier prefs.js ou user.js.

        Args:
            path: Chemin du fichier de préférences
            prefs: Dictionnaire des préférences {nom: valeur}
            backup: Si True, crée une sauvegarde du fichier original

        Returns:
            bool: True si l'écriture réussit, False sinon
        """
        file_path = Path(path)
        self.log_debug(f"Écriture du fichier de préférences Mozilla: {file_path}")

        try:
            # Formater le contenu
            content = self._format_prefs_js(prefs)

            # Écrire le fichier
            return self._write_file_content(file_path, content, backup=backup)
        except Exception as e:
            self.log_error(f"Erreur lors de l'écriture du fichier de préférences {file_path}: {e}", exc_info=True)
            return False

    def get_pref(self, path: Union[str, Path], pref_name: str, default: Any = None) -> Any:
        """
        Récupère une préférence spécifique d'un fichier de préférences.

        Args:
            path: Chemin du fichier de préférences
            pref_name: Nom de la préférence à récupérer
            default: Valeur par défaut si la préférence n'existe pas

        Returns:
            Any: Valeur de la préférence ou valeur par défaut
        """
        prefs = self.read_prefs_file(path)
        if prefs is None:
            return default

        return prefs.get(pref_name, default)

    def set_pref(self, path: Union[str, Path], pref_name: str, value: Any, backup: bool = True) -> bool:
        """
        Définit une préférence dans un fichier de préférences.

        Args:
            path: Chemin du fichier de préférences
            pref_name: Nom de la préférence à définir
            value: Nouvelle valeur de la préférence
            backup: Si True, crée une sauvegarde du fichier original

        Returns:
            bool: True si la modification réussit, False sinon
        """
        prefs = self.read_prefs_file(path)
        if prefs is None:
            # Si le fichier n'existe pas, créer un nouveau dictionnaire
            prefs = {}

        # Mettre à jour la préférence
        prefs[pref_name] = value

        # Écrire le fichier mis à jour
        return self.write_prefs_file(path, prefs, backup=backup)

    def remove_pref(self, path: Union[str, Path], pref_name: str, backup: bool = True) -> bool:
        """
        Supprime une préférence d'un fichier de préférences.

        Args:
            path: Chemin du fichier de préférences
            pref_name: Nom de la préférence à supprimer
            backup: Si True, crée une sauvegarde du fichier original

        Returns:
            bool: True si la suppression réussit, False sinon
        """
        prefs = self.read_prefs_file(path)
        if prefs is None:
            return False

        # Vérifier si la préférence existe
        if pref_name not in prefs:
            self.log_debug(f"Préférence '{pref_name}' non trouvée dans {path}")
            return True

        # Supprimer la préférence
        del prefs[pref_name]

        # Écrire le fichier mis à jour
        return self.write_prefs_file(path, prefs, backup=backup)

    def get_prefs_by_prefix(self, path: Union[str, Path], prefix: str) -> Dict[str, Any]:
        """
        Récupère toutes les préférences dont le nom commence par un préfixe spécifique.

        Args:
            path: Chemin du fichier de préférences
            prefix: Préfixe des noms de préférences à récupérer

        Returns:
            Dict[str, Any]: Dictionnaire des préférences filtrées {nom: valeur}
        """
        prefs = self.read_prefs_file(path)
        if prefs is None:
            return {}

        # Filtrer les préférences par préfixe
        return {name: value for name, value in prefs.items() if name.startswith(prefix)}

    def set_multiple_prefs(self, path: Union[str, Path], prefs_to_set: Dict[str, Any], backup: bool = True) -> bool:
        """
        Définit plusieurs préférences en une seule opération.

        Args:
            path: Chemin du fichier de préférences
            prefs_to_set: Dictionnaire des préférences à définir {nom: valeur}
            backup: Si True, crée une sauvegarde du fichier original

        Returns:
            bool: True si la modification réussit, False sinon
        """
        prefs = self.read_prefs_file(path)
        if prefs is None:
            # Si le fichier n'existe pas, utiliser seulement les nouvelles préférences
            prefs = prefs_to_set.copy()
        else:
            # Mettre à jour les préférences existantes
            prefs.update(prefs_to_set)

        # Écrire le fichier mis à jour
        return self.write_prefs_file(path, prefs, backup=backup)

    def find_profile_path(self, app_name: str = "thunderbird", profile_name: Optional[str] = None) -> Optional[Path]:
        """
        Trouve le chemin d'un profil Mozilla.

        Args:
            app_name: Nom de l'application ("thunderbird" ou "firefox")
            profile_name: Nom du profil à rechercher ou None pour utiliser le profil par défaut

        Returns:
            Optional[Path]: Chemin du profil ou None si non trouvé
        """
        # Déterminer le chemin de base en fonction du système d'exploitation
        home = Path.home()

        if os.name == "nt":  # Windows
            base_path = home / "AppData" / "Roaming" / app_name.capitalize()
        elif os.name == "posix":  # Linux/Unix
            base_path = home / f".{app_name}"
        elif os.name == "darwin":  # macOS
            base_path = home / "Library" / "Application Support" / app_name.capitalize()
        else:
            self.log_error(f"Système d'exploitation non pris en charge: {os.name}")
            return None

        profiles_ini_path = base_path / "profiles.ini"

        # Vérifier si profiles.ini existe
        if not profiles_ini_path.exists():
            self.log_error(f"Fichier profiles.ini non trouvé: {profiles_ini_path}")
            return None

        # Lire profiles.ini
        profiles_ini = self.read_ini_file(profiles_ini_path)
        if profiles_ini is None:
            return None

        # Parcourir les sections de profils
        default_profile = None
        named_profile = None

        for section, values in profiles_ini.items():
            if not section.startswith("Profile"):
                continue

            # Vérifier si c'est le profil par défaut
            is_default = values.get("Default", "0") == "1"

            # Vérifier si c'est le profil recherché par nom
            if profile_name is not None and values.get("Name") == profile_name:
                named_profile = values
                break

            # Garder le profil par défaut
            if is_default:
                default_profile = values

        # Utiliser le profil trouvé ou le profil par défaut
        profile_data = named_profile or default_profile

        if not profile_data:
            self.log_error(f"Aucun profil {'nommé ' + profile_name if profile_name else 'par défaut'} trouvé.")
            return None

        # Construire le chemin du profil
        if profile_data.get("IsRelative", "1") == "1":
            # Chemin relatif au répertoire de base
            profile_path = base_path / profile_data.get("Path", "")
        else:
            # Chemin absolu
            profile_path = Path(profile_data.get("Path", ""))

        if not profile_path.exists():
            self.log_error(f"Répertoire de profil introuvable: {profile_path}")
            return None

        self.log_debug(f"Profil trouvé: {profile_path}")
        return profile_path

    def backup_prefs_file(self, path: Union[str, Path]) -> Optional[str]:
        """
        Crée une sauvegarde d'un fichier de préférences.

        Args:
            path: Chemin du fichier de préférences

        Returns:
            Optional[str]: Chemin de la sauvegarde ou None en cas d'erreur
        """
        return self._backup_file(path)

    def restore_prefs_file(self, backup_path: Union[str, Path], dest_path: Optional[Union[str, Path]] = None) -> bool:
        """
        Restaure un fichier de préférences à partir d'une sauvegarde.

        Args:
            backup_path: Chemin du fichier de sauvegarde
            dest_path: Chemin de destination ou None pour utiliser le chemin original

        Returns:
            bool: True si la restauration réussit, False sinon
        """
        backup_file = Path(backup_path)

        if not backup_file.exists():
            self.log_error(f"Fichier de sauvegarde introuvable: {backup_file}")
            return False

        # Déterminer le chemin de destination
        if dest_path is None:
            # Extraire le chemin original à partir du nom de la sauvegarde
            # Supposer que le nom de la sauvegarde est du format "original.bak_timestamp"
            if not backup_file.name.endswith(".bak"):
                self.log_error(f"Format de nom de sauvegarde non reconnu: {backup_file}")
                return False

            dest_file = backup_file.parent / backup_file.name.split(".bak_")[0]
        else:
            dest_file = Path(dest_path)

        try:
            # Lire le contenu de la sauvegarde
            content = self._read_file_content(backup_file)
            if content is None:
                return False

            # Écrire le contenu dans le fichier de destination
            return self._write_file_content(dest_file, content, backup=False)
        except Exception as e:
            self.log_error(f"Erreur lors de la restauration de {backup_file} vers {dest_file}: {e}", exc_info=True)
            return False

    # --- Gestion des fichiers de politique (mozilla.cfg, policies.json) ---

    def _parse_cfg_file(self, content: str) -> Dict[str, Any]:
        """
        Parse un fichier .cfg de Mozilla (format similaire à prefs.js mais avec lockPref, etc.).

        Args:
            content: Contenu du fichier à parser

        Returns:
            Dict[str, Any]: Dictionnaire des préférences {nom: {valeur: value, type: lockPref|defaultPref}}
        """
        self.log_debug("Parsing d'un fichier de configuration .cfg de Mozilla")

        # Regex pour extraire les préférences verrouillées, par défaut, etc.
        patterns = {
            "lockPref": r'lockPref\("([^"]+)",\s*([^)]+)\);',
            "defaultPref": r'defaultPref\("([^"]+)",\s*([^)]+)\);',
            "pref": r'pref\("([^"]+)",\s*([^)]+)\);'
        }

        prefs = {}

        for pref_type, pattern in patterns.items():
            matches = re.findall(pattern, content)

            for name, value_str in matches:
                # Convertir la valeur en type Python approprié
                try:
                    # Essayer de parser en JSON pour obtenir le type correct
                    value_str = value_str.replace('true', 'true').replace('false', 'false')
                    value = json.loads(value_str)
                except json.JSONDecodeError:
                    # Si échec, conserver comme chaîne
                    value = value_str.strip('"\'')

                prefs[name] = {"value": value, "type": pref_type}

        return prefs

    def _format_cfg_file(self, prefs: Dict[str, Dict[str, Any]]) -> str:
        """
        Formate un dictionnaire de préférences en contenu de fichier .cfg.

        Args:
            prefs: Dictionnaire des préférences {nom: {valeur: value, type: lockPref|defaultPref}}

        Returns:
            str: Contenu formaté pour un fichier .cfg
        """
        lines = [
            '// Mozilla Configuration File',
            '//',
            '// This file contains preferences that can be locked or set as defaults',
            '// for the organization deploying this file.',
            ''
        ]

        # Trier les préférences pour une sortie prévisible
        sorted_prefs = sorted(prefs.items())

        for name, pref_data in sorted_prefs:
            value = pref_data["value"]
            pref_type = pref_data.get("type", "lockPref")  # Par défaut, utiliser lockPref

            # Formater la valeur en fonction de son type
            if isinstance(value, str):
                # Les chaînes doivent être entre guillemets doubles
                value_str = f'"{value}"'
            elif isinstance(value, bool):
                # Convertir les booléens Python en booléens JavaScript
                value_str = 'true' if value else 'false'
            else:
                # Nombres et autres valeurs
                value_str = str(value)

            lines.append(f'{pref_type}("{name}", {value_str});')

        return '\n'.join(lines) + '\n'

    def read_cfg_file(self, path: Union[str, Path]) -> Optional[Dict[str, Dict[str, Any]]]:
        """
        Lit un fichier .cfg de Mozilla.

        Args:
            path: Chemin du fichier .cfg

        Returns:
            Optional[Dict[str, Dict[str, Any]]]: Dictionnaire des préférences ou None en cas d'erreur
        """
        file_path = Path(path)
        self.log_debug(f"Lecture du fichier de configuration .cfg de Mozilla: {file_path}")

        # Lire le contenu du fichier
        content = self._read_file_content(file_path)
        if content is None:
            return None

        try:
            # Parser le contenu
            prefs = self._parse_cfg_file(content)
            self.log_debug(f"Fichier .cfg lu avec succès: {len(prefs)} préférences trouvées")
            return prefs
        except Exception as e:
            self.log_error(f"Erreur lors du parsing du fichier .cfg {file_path}: {e}", exc_info=True)
            return None

    def write_cfg_file(self, path: Union[str, Path], prefs: Dict[str, Dict[str, Any]], backup: bool = True) -> bool:
        """
        Écrit un dictionnaire de préférences dans un fichier .cfg.

        Args:
            path: Chemin du fichier .cfg
            prefs: Dictionnaire des préférences {nom: {valeur: value, type: lockPref|defaultPref}}
            backup: Si True, crée une sauvegarde du fichier original

        Returns:
            bool: True si l'écriture réussit, False sinon
        """
        file_path = Path(path)
        self.log_debug(f"Écriture du fichier de configuration .cfg de Mozilla: {file_path}")

        try:
            # Formater le contenu
            content = self._format_cfg_file(prefs)

            # Écrire le fichier
            return self._write_file_content(file_path, content, backup=backup)
        except Exception as e:
            self.log_error(f"Erreur lors de l'écriture du fichier .cfg {file_path}: {e}", exc_info=True)
            return False

    def read_policies_json(self, path: Union[str, Path]) -> Optional[Dict[str, Any]]:
        """
        Lit un fichier policies.json de Mozilla.

        Args:
            path: Chemin du fichier policies.json

        Returns:
            Optional[Dict[str, Any]]: Structure de politiques ou None en cas d'erreur
        """
        return self.read_json_file(path)

    def write_policies_json(self, path: Union[str, Path], policies: Dict[str, Any], backup: bool = True) -> bool:
        """
        Écrit un dictionnaire de politiques dans un fichier policies.json.

        Args:
            path: Chemin du fichier policies.json
            policies: Dictionnaire des politiques
            backup: Si True, crée une sauvegarde du fichier original

        Returns:
            bool: True si l'écriture réussit, False sinon
        """
        return self.write_json_file(path, policies, backup=backup)

    def get_thunderbird_account_settings(self, profile_path: Optional[Union[str, Path]] = None) -> Dict[str, Dict[str, Any]]:
        """
        Récupère les paramètres de compte Thunderbird à partir du fichier prefs.js.

        Args:
            profile_path: Chemin du profil Thunderbird ou None pour le rechercher automatiquement

        Returns:
            Dict[str, Dict[str, Any]]: Structure des paramètres de compte
        """
        # Trouver le chemin du profil si non spécifié
        if profile_path is None:
            profile_path = self.find_profile_path("thunderbird")
            if profile_path is None:
                self.log_error("Impossible de trouver le profil Thunderbird")
                return {}

        # Chemin du fichier prefs.js
        prefs_path = Path(profile_path) / "prefs.js"

        # Lire les préférences
        prefs = self.read_prefs_file(prefs_path)
        if prefs is None:
            self.log_error(f"Impossible de lire le fichier prefs.js: {prefs_path}")
            return {}

        # Extraire les identités (adresses email)
        identities = {}
        for name, value in prefs.items():
            if name.startswith("mail.identity.id"):
                # Extraire l'ID d'identité
                id_parts = name.split(".")
                if len(id_parts) >= 4:
                    id_value = id_parts[3]  # Ex: mail.identity.id1.useremail -> id1
                    key = id_parts[4] if len(id_parts) > 4 else None

                    if id_value not in identities:
                        identities[id_value] = {}

                    if key:
                        identities[id_value][key] = value

        # Extraire les serveurs
        servers = {}
        for name, value in prefs.items():
            if name.startswith("mail.server.server"):
                # Extraire l'ID de serveur
                id_parts = name.split(".")
                if len(id_parts) >= 4:
                    id_value = id_parts[3]  # Ex: mail.server.server1.hostname -> server1
                    key = id_parts[4] if len(id_parts) > 4 else None

                    if id_value not in servers:
                        servers[id_value] = {}

                    if key:
                        servers[id_value][key] = value

        # Extraire les comptes
        accounts = {}
        account_list = prefs.get("mail.accountmanager.accounts", "").split(",")

        for account_id in account_list:
            if not account_id:
                continue

            accounts[account_id] = {
                "identities": [],
                "servers": []
            }

            # Associer les identités aux comptes
            account_identities = prefs.get(f"mail.account.{account_id}.identities", "").split(",")
            for identity_id in account_identities:
                if identity_id and identity_id in identities:
                    accounts[account_id]["identities"].append({
                        "id": identity_id,
                        **identities[identity_id]
                    })

            # Associer les serveurs aux comptes
            server_id = prefs.get(f"mail.account.{account_id}.server")
            if server_id and server_id in servers:
                accounts[account_id]["servers"].append({
                    "id": server_id,
                    **servers[server_id]
                })

        return {
            "accounts": accounts,
            "identities": identities,
            "servers": servers
        }

    def set_thunderbird_account_setting(self, account_id: str, setting_type: str, setting_id: str,
                                        key: str, value: Any, profile_path: Optional[Union[str, Path]] = None) -> bool:
        """
        Définit un paramètre de compte Thunderbird.

        Args:
            account_id: ID du compte (ex: "account1")
            setting_type: Type de paramètre ("identity" ou "server")
            setting_id: ID du paramètre (ex: "id1" pour identity, "server1" pour server)
            key: Clé du paramètre (ex: "useremail" pour identity, "hostname" pour server)
            value: Nouvelle valeur du paramètre
            profile_path: Chemin du profil Thunderbird ou None pour le rechercher automatiquement

        Returns:
            bool: True si la modification réussit, False sinon
        """
        # Trouver le chemin du profil si non spécifié
        if profile_path is None:
            profile_path = self.find_profile_path("thunderbird")
            if profile_path is None:
                self.log_error("Impossible de trouver le profil Thunderbird")
                return False

        # Chemin du fichier prefs.js
        prefs_path = Path(profile_path) / "prefs.js"

        # Déterminer le nom de la préférence en fonction du type
        if setting_type == "identity":
            pref_name = f"mail.identity.{setting_id}.{key}"
        elif setting_type == "server":
            pref_name = f"mail.server.{setting_id}.{key}"
        elif setting_type == "account":
            pref_name = f"mail.account.{account_id}.{key}"
        else:
            self.log_error(f"Type de paramètre non pris en charge: {setting_type}")
            return False

        # Définir la préférence
        return self.set_pref(prefs_path, pref_name, value)

    def get_addressbook_entries(self, profile_path: Optional[Union[str, Path]] = None) -> Dict[str, Dict[str, Any]]:
        """
        Récupère les entrées du carnet d'adresses Thunderbird.

        Args:
            profile_path: Chemin du profil Thunderbird ou None pour le rechercher automatiquement

        Returns:
            Dict[str, Dict[str, Any]]: Structure des entrées du carnet d'adresses
        """
        # Trouver le chemin du profil si non spécifié
        if profile_path is None:
            profile_path = self.find_profile_path("thunderbird")
            if profile_path is None:
                self.log_error("Impossible de trouver le profil Thunderbird")
                return {}

        profile_path = Path(profile_path)

        # Le carnet d'adresses est stocké dans le fichier "abook.mab" ou dans SQLite "addrbook.sqlite"
        abook_path = profile_path / "abook.mab"
        sqlite_path = profile_path / "addrbook.sqlite"

        if sqlite_path.exists():
            self.log_warning("Le carnet d'adresses utilise SQLite, qui n'est pas pris en charge par ce module.")
            self.log_warning("Utilisez un module SQLite pour lire addrbook.sqlite.")
            return {}

        if not abook_path.exists():
            self.log_warning(f"Fichier de carnet d'adresses introuvable: {abook_path}")
            return {}

        self.log_warning("La lecture du format MAB du carnet d'adresses n'est pas prise en charge nativement.")
        self.log_warning("Utilisez des outils externes ou LDAP pour gérer le carnet d'adresses.")
        return {}

    def configure_autoconfig(self, install_dir: Optional[Union[str, Path]] = None) -> bool:
        """
        Configure l'autoconfiguration pour Firefox ou Thunderbird.

        Args:
            install_dir: Répertoire d'installation ou None pour utiliser l'emplacement par défaut

        Returns:
            bool: True si la configuration réussit, False sinon
        """
        # Déterminer le répertoire d'installation
        if install_dir is None:
            if os.name == "nt":  # Windows
                install_dir = Path("C:/Program Files/Mozilla Firefox")
            elif os.name == "posix":  # Linux/Unix
                install_dir = Path("/usr/lib/firefox")
            elif os.name == "darwin":  # macOS
                install_dir = Path("/Applications/Firefox.app/Contents/MacOS")
            else:
                self.log_error(f"Système d'exploitation non pris en charge: {os.name}")
                return False
        else:
            install_dir = Path(install_dir)

        # Vérifier si le répertoire d'installation existe
        if not install_dir.exists():
            self.log_error(f"Répertoire d'installation introuvable: {install_dir}")
            return False

        # Créer le répertoire defaults/pref si nécessaire
        defaults_dir = install_dir / "defaults"
        pref_dir = defaults_dir / "pref"

        try:
            pref_dir.mkdir(parents=True, exist_ok=True)
        except Exception as e:
            self.log_error(f"Impossible de créer le répertoire defaults/pref: {e}")
            return False

        # Créer le fichier autoconfig.js
        autoconfig_content = 'pref("general.config.filename", "mozilla.cfg");\n'
        autoconfig_content += 'pref("general.config.obscure_value", 0);\n'

        autoconfig_path = pref_dir / "autoconfig.js"
        autoconfig_success = self._write_file_content(autoconfig_path, autoconfig_content)

        if not autoconfig_success:
            return False

        # Créer le fichier mozilla.cfg (vide par défaut)
        mozilla_cfg_path = install_dir / "mozilla.cfg"
        if not mozilla_cfg_path.exists():
            mozilla_cfg_content = '// Fichier de configuration Mozilla\n\n'
            return self._write_file_content(mozilla_cfg_path, mozilla_cfg_content)

        return True

    def add_lockpref_to_cfg(self, path: Union[str, Path], pref_name: str, value: Any, backup: bool = True) -> bool:
        """
        Ajoute une préférence verrouillée à un fichier .cfg.

        Args:
            path: Chemin du fichier .cfg
            pref_name: Nom de la préférence à verrouiller
            value: Valeur de la préférence
            backup: Si True, crée une sauvegarde du fichier original

        Returns:
            bool: True si l'ajout réussit, False sinon
        """
        # Lire le fichier .cfg existant
        cfg_prefs = self.read_cfg_file(path)
        if cfg_prefs is None:
            # Si le fichier n'existe pas, créer un nouveau dictionnaire
            cfg_prefs = {}

        # Ajouter ou mettre à jour la préférence verrouillée
        cfg_prefs[pref_name] = {"value": value, "type": "lockPref"}

        # Écrire le fichier mis à jour
        return self.write_cfg_file(path, cfg_prefs, backup=backup)

    def add_defaultpref_to_cfg(self, path: Union[str, Path], pref_name: str, value: Any, backup: bool = True) -> bool:
        """
        Ajoute une préférence par défaut à un fichier .cfg.

        Args:
            path: Chemin du fichier .cfg
            pref_name: Nom de la préférence par défaut
            value: Valeur de la préférence
            backup: Si True, crée une sauvegarde du fichier original

        Returns:
            bool: True si l'ajout réussit, False sinon
        """
        # Lire le fichier .cfg existant
        cfg_prefs = self.read_cfg_file(path)
        if cfg_prefs is None:
            # Si le fichier n'existe pas, créer un nouveau dictionnaire
            cfg_prefs = {}

        # Ajouter ou mettre à jour la préférence par défaut
        cfg_prefs[pref_name] = {"value": value, "type": "defaultPref"}

        # Écrire le fichier mis à jour
        return self.write_cfg_file(path, cfg_prefs, backup=backup)

def configure_thunderbird_proxy(self, proxy_type: str, proxy_host: str, proxy_port: int,
                               profile_path: Optional[Union[str, Path]] = None) -> bool:
    """
    Configure les paramètres de proxy pour Thunderbird.

    Args:
        proxy_type: Type de proxy ("none", "manual", "auto")
        proxy_host: Hôte du proxy (pour "manual")
        proxy_port: Port du proxy (pour "manual")
        profile_path: Chemin du profil Thunderbird ou None pour le rechercher automatiquement

    Returns:
        bool: True si la configuration réussit, False sinon
    """
    # Trouver le chemin du profil si non spécifié
    if profile_path is None:
        profile_path = self.find_profile_path("thunderbird")
        if profile_path is None:
            self.log_error("Impossible de trouver le profil Thunderbird")
            return False

    # Chemin du fichier prefs.js
    prefs_path = Path(profile_path) / "prefs.js"

    # Définir les préférences de proxy
    prefs_to_set = {}

    if proxy_type == "none":
        prefs_to_set["network.proxy.type"] = 0
    elif proxy_type == "manual":
        prefs_to_set["network.proxy.type"] = 1
        prefs_to_set["network.proxy.http"] = proxy_host
        prefs_to_set["network.proxy.http_port"] = proxy_port
        prefs_to_set["network.proxy.ssl"] = proxy_host
        prefs_to_set["network.proxy.ssl_port"] = proxy_port
        prefs_to_set["network.proxy.ftp"] = proxy_host
        prefs_to_set["network.proxy.ftp_port"] = proxy_port
        prefs_to_set["network.proxy.socks"] = proxy_host
        prefs_to_set["network.proxy.socks_port"] = proxy_port
        prefs_to_set["network.proxy.share_proxy_settings"] = True
    elif proxy_type == "auto":
        prefs_to_set["network.proxy.type"] = 2
    else:
        self.log_error(f"Type de proxy non pris en charge: {proxy_type}")
        return False

    # Définir toutes les préférences en une seule opération
    return self.set_multiple_prefs(prefs_path, prefs_to_set)

def configure_firefox_enterprise_policies(self, policies: Dict[str, Any], install_dir: Optional[Union[str, Path]] = None) -> bool:
    """
    Configure les politiques d'entreprise pour Firefox.

    Args:
        policies: Dictionnaire des politiques à configurer
        install_dir: Répertoire d'installation de Firefox ou None pour utiliser l'emplacement par défaut

    Returns:
        bool: True si la configuration réussit, False sinon
    """
    # Déterminer le répertoire d'installation
    if install_dir is None:
        if os.name == "nt":  # Windows
            install_dir = Path("C:/Program Files/Mozilla Firefox")
        elif os.name == "posix":  # Linux/Unix
            install_dir = Path("/usr/lib/firefox")
        elif os.name == "darwin":  # macOS
            install_dir = Path("/Applications/Firefox.app/Contents/MacOS")
        else:
            self.log_error(f"Système d'exploitation non pris en charge: {os.name}")
            return False
    else:
        install_dir = Path(install_dir)

    # Vérifier si le répertoire d'installation existe
    if not install_dir.exists():
        self.log_error(f"Répertoire d'installation Firefox introuvable: {install_dir}")
        return False

    # Créer le répertoire de distribution si nécessaire
    distribution_dir = install_dir / "distribution"
    if not distribution_dir.exists():
        try:
            distribution_dir.mkdir(parents=True, exist_ok=True)
        except Exception as e:
            self.log_error(f"Impossible de créer le répertoire de distribution: {e}")
            return False

    # Préparer le contenu policies.json
    policies_content = {
        "policies": policies
    }

    # Écrire le fichier policies.json
    policies_path = distribution_dir / "policies.json"
    return self.write_json_file(policies_path, policies_content)

def configure_thunderbird_filters(self, filters: List[Dict[str, Any]], profile_path: Optional[Union[str, Path]] = None) -> bool:
    """
    Configure les filtres de messagerie pour Thunderbird.

    Args:
        filters: Liste des filtres à configurer
        profile_path: Chemin du profil Thunderbird ou None pour le rechercher automatiquement

    Returns:
        bool: True si la configuration réussit, False sinon
    """
    # Trouver le chemin du profil si non spécifié
    if profile_path is None:
        profile_path = self.find_profile_path("thunderbird")
        if profile_path is None:
            self.log_error("Impossible de trouver le profil Thunderbird")
            return False

    profile_path = Path(profile_path)

    # Les filtres sont stockés dans le répertoire "msgFilterRules.dat"
    filters_dir = profile_path
    filters_file = filters_dir / "msgFilterRules.dat"

    # Formater les filtres au format Thunderbird
    lines = []

    # En-tête du fichier
    lines.append("version=\"9\"")
    lines.append("logging=\"no\"")

    # Ajouter chaque filtre
    for i, filter_data in enumerate(filters):
        lines.append("")
        lines.append(f"name=\"{filter_data.get('name', f'Filter {i+1}')}\"")
        lines.append(f"enabled=\"{filter_data.get('enabled', 'yes')}\"")
        lines.append(f"type=\"{filter_data.get('type', '17')}\"")  # 17 = tous les messages
        lines.append(f"action=\"{filter_data.get('action', 'Move to folder')}\"")

        # Ajouter les conditions
        conditions = filter_data.get("conditions", [])
        for j, condition in enumerate(conditions):
            op = condition.get("operator", "contains")
            header = condition.get("header", "subject")
            value = condition.get("value", "")

            lines.append(f"condition=\"{header},{op},{value}\"")

        # Ajouter les actions
        actions = filter_data.get("actions", [])
        for j, action in enumerate(actions):
            action_type = action.get("type", "MoveToFolder")
            target = action.get("target", "")

            lines.append(f"actionValue=\"{target}\"")
            lines.append(f"actionType=\"{action_type}\"")

    # Écrire le fichier
    content = "\n".join(lines) + "\n"
    return self._write_file_content(filters_file, content)

    def update_lightning_calendar(self, ics_url: str, name: str, color: str = "#3366CC",
                                profile_path: Optional[Union[str, Path]] = None) -> bool:
        """
        Ajoute ou met à jour un calendrier Lightning dans Thunderbird.

        Args:
            ics_url: URL du calendrier ICS
            name: Nom du calendrier
            color: Couleur du calendrier au format hexadécimal
            profile_path: Chemin du profil Thunderbird ou None pour le rechercher automatiquement

        Returns:
            bool: True si la mise à jour réussit, False sinon
        """
        # Trouver le chemin du profil si non spécifié
        if profile_path is None:
            profile_path = self.find_profile_path("thunderbird")
            if profile_path is None:
                self.log_error("Impossible de trouver le profil Thunderbird")
                return False

        profile_path = Path(profile_path)

        # Le calendrier est stocké dans le fichier calendar-prefs.js ou local-prefs.js
        calendar_prefs_path = profile_path / "calendar-prefs.js"
        if not calendar_prefs_path.exists():
            calendar_prefs_path = profile_path / "prefs.js"

        # Lire les préférences existantes
        prefs = self.read_prefs_file(calendar_prefs_path)
        if prefs is None:
            self.log_error(f"Impossible de lire le fichier de préférences: {calendar_prefs_path}")
            return False

        # Trouver les calendriers existants
        calendars = []
        calendar_ids = []

        for key, value in prefs.items():
            if key == "calendar.list.sortOrder":
                calendar_ids = value.split()

        # Vérifier si le calendrier existe déjà
        calendar_id = None
        for cal_id in calendar_ids:
            cal_uri = prefs.get(f"calendar.registry.{cal_id}.uri")
            if cal_uri == ics_url:
                calendar_id = cal_id
                break

        # Si le calendrier n'existe pas, créer un nouvel ID
        if calendar_id is None:
            # Générer un nouvel ID unique
            import uuid
            calendar_id = str(uuid.uuid4())

            # Ajouter l'ID à la liste
            if "calendar.list.sortOrder" in prefs:
                prefs["calendar.list.sortOrder"] += f" {calendar_id}"
            else:
                prefs["calendar.list.sortOrder"] = calendar_id

        # Mettre à jour les propriétés du calendrier
        prefs[f"calendar.registry.{calendar_id}.uri"] = ics_url
        prefs[f"calendar.registry.{calendar_id}.name"] = name
        prefs[f"calendar.registry.{calendar_id}.color"] = color
        prefs[f"calendar.registry.{calendar_id}.type"] = "ics"
        prefs[f"calendar.registry.{calendar_id}.readOnly"] = True
        prefs[f"calendar.registry.{calendar_id}.disabled"] = False
        prefs[f"calendar.registry.{calendar_id}.refreshInterval"] = 30  # 30 minutes

        # Écrire les préférences mises à jour
        return self.write_prefs_file(calendar_prefs_path, prefs)